# Hey man &mdash; I'm wired: Caffeine Monitor

Just over two weeks ago the second instalment of [Build Conference][] was coming to an end. I had the pleasure of attending this hand made web design conference set in stormy Belfast, tales of which I regaled on my own [website](http://jasoncale.com/articles/9-build-conference-2010). However there was an addendum alluded to in that article which I'd like to share here. [Andy McMillan](http://twitter.com/#!/goodonpaper) who runs Build approached [Free Range][] back in September about a little project he wanted to include in the conference.

Dubbed [Caffeine Monitor][] the concept was to create a realtime visualisation of conference attendee caffeine consumption. Sponsored by Campaign Monitor and paired with data-vis stalwart Nicholas Felton who would design and create the HTML & CSS template which we could populate with data.

We've had a busy few months but decided we could dedicate our friday afternoons to building the app as a fun way to punctuate our week; of course the various technical challenges which surfaced are what I'm here to divulge.

## Iteration one.

Once we'd written some stories with Andy &amp; Nicholas to describe some of the functionality [Kalv][] and I kicked off the development by pairing on the data collection and exposing the raw data as statistics to an un-styled front end.

The data capture side of the app itself is pretty simple; a form with two buttons &mdash; one for coffee, one for tea &mdash; to record drink "purchases" from which we can derive some interesting statistics. 

Fairly standard stuff; We bashed out the stories and with all the tests passing, we deployed the working code and went to the pub.

## Iteration two.

With the basic skeleton of the app up and running &amp; the infographic template sitting in our inbox from Nicholas, Kalv &amp; I set to work stitching it all together. 

We added a bit of stats caching while we were at it, and tidied up our stats class, added some integration testing around the CSS to check all the bar charts were displaying as they should. It was easy sailing along the upstream; we pushed, deployed and checked our browsers &mdash; smile. 

Knowing the next bit would be a little more taxing we climbed into the soft embrace of the weekend.

## Iteration three.

[Chris][] hijacked me to work on his blog, I submitted; In my absence [James][] started work on the offline capability for the data capture screen. One of our concerns from the get go was that this app had to "just work" &mdash; it was going to be used on flaky wifi, outside the venue, and by helpers Andy had rounded up &mdash; there was no breathing space on the day, we need to capture and display the caffeine intake in short bursts throughout the day, any down time would be disastrous to the effectiveness of the product.

That afternoon James wrote the javascript needed for the app to work offline, which would be basis we'd build on over the next two iterations. Just as the pub was calling out to our week worn bones, we huddled around James and discussed some issues with the offline manifest which was being generated by Rails to tell the browser what to cache for offline use.

But before we get into that, lets take a quick taste of the exciting javascript feast James had cooked up that afternoon.

The first thing the javascript does when it loads the page is initialise a database on the client (browser). We knew we would be using devices with webkit to record the drinks so we knew we'd have a tasty HTML5 offline database.

We then hijacked the form containing the two submit buttons (one for tea, one for coffee) replacing their default click behaviour with a javascript implementation which recorded a drink "purchase" in the local database without submitting the form. When we record a drink in the database we note what type of drink was purchased, assign a UUID and set its state as unsynced. The click action also calls a function which tries to sync with the server.

Syncing with the server was a pretty simple idea, we pull all the drinks from the database that are currently unsynced and post each one to the server to be recorded centrally. If the server creates it's own record successfully it posts back the UUID as a successful payload (http status 200).

## Offline data entry

  * Flaky wifi / No web access
  * Tried static page in public but realised that we could cache_page in the controller.  I think we turned this off in the end though.
  * Rack-offline intentionally doesn't work in development - this was confusing.  The chrome error for this is also confusing - it makes it sound as though some elements were cached when, in fact, nothing was.
  * We only specified the app-cache manifest on the data entry page (we created a separate layout) as we didn't want the stats page cached.
  * Problems with clearing app cache - there doesn't appear to be a way to do it through the browser.

## Security through obscurity for admin

  * We wanted it to be a 'desktop' app
  * It was hard to get it 'secure' as a 'desktop' app.
  * HTTP Basic auth did work but prompted you for the username/password on every request.
  * Cookies weren't shared across the browser and 'desktop' app.
  * Redirects aren't followed in 'desktop' apps which means we couldn't use the standard login form.
  
## Data entry

  * Bulk upload of data for performance reasons
  * Optimised for ios devices - ipad, iphone, ipod touch
  
## Performance

  * We increased the number of heroku dynos and they easily coped with the traffic
  * We cached the data for the bargraph at 5 minute intervals
  
## Stats page

  * CSS/Scaling of the stats page
  * Media queries
  * Bar graphs
  
[Build Conference]: http://buildconf.com
[Campaign Monitor]: http://campaignmonitor.com
[Caffeine Monitor]: http://cm.buildconf.com

[Free Range]: http://gofreerange.com
[Kalv]: http://gofreerange.com/#kalvir-sandhu
[James]: http://gofreerange.com/#james-adam
[Chris]: http://gofreerange.com/#chris-roos
  
:render_as: Blog
:kind: draft
:written_with: Kramdown
:author: jason-cale