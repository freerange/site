<!DOCTYPE html>
<html lang="en">
<head>
  <meta content="HTML Tidy for HTML5 for Mac OS X version 5.2.0" name="generator">
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <meta content="A small software development company based in London, UK." name="description">
  <meta content="GNqgxou6cYLkYq9l47mZM00R93JN49KqRhJebklH7uo" name="google-site-verification">
  <meta content="width=device-width" name="viewport">
  <meta content="IE=edge" http-equiv="X-UA-Compatible">
  <meta content="ruby rails software development london" name="keywords">
  <meta content="telephone=no" name="format-detection">
  <link href="/favicon.ico" rel="shortcut icon">
  <link href="/assets/application-e4364b3782cc7477f226bc8504403fa41bfb8d1f7a4ed67eb3fe80f20bd5b014.css" media="all" rel="stylesheet">
  <link href="http://feeds.gofreerange.com/GoFreeRangeBlog" rel='alternate' title='Go Free Range Blog' type='application/atom+xml'>
  <script src='http://use.typekit.com/rny4upv.js' type='text/javascript'>
  </script>
  <script>
  try{Typekit.load();}catch(e){}
  </script>
  <title>Understanding one-time passwords — Go Free Range.</title>
</head>
<body class="blog">
  <div id="page">
    <div class="group" id="header">
      <ul class='nav group' id='blog_nav'>
        <li id='link_home'>
          <p>Visit our <a href='/'>company website</a></p>
        </li>
        <li id='link_rss'>
          <p>Grab the <a href='http://feeds.gofreerange.com/GoFreeRangeBlog' title='RSS Feed from Feedburner'>RSS</a> feed</p>
        </li>
      </ul>
      <h1 id="logo"><a href="/blog" title="Go to blog index">Blog index</a></h1>
    </div>
    <div class="group" id="content">
      <div class="blog_entry group">
        <p class="article_date">Friday 06th January, 2017</p>
        <div class="author">
          <img alt="Chris Roos" src="images/people/chris-roos.jpg"> <span>by Chris Roos</span>
        </div>
        <div class="content">
          <h2 id="understanding-one-time-passwords">Understanding one-time passwords</h2>
          <p>I recently spent some time investigating the <a href="https://en.wikipedia.org/wiki/HMAC-based_One-time_Password_Algorithm">HOTP</a> (HMAC-based) and <a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm">TOTP</a> (Time-based) one-time password algorithms. You’re probably relying on one of these algorithms if you’ve enabled <a href="https://en.wikipedia.org/wiki/Multi-factor_authentication">two-factor authentication</a> for a service (e.g. GitHub) and are using something like <a href="https://en.wikipedia.org/wiki/Google_Authenticator">Google Authenticator</a>, <a href="https://www.authy.com/">Authy</a> or <a href="https://support.1password.com/one-time-passwords/">1Password</a> to generate a 6 digit code when signing in.</p>
          <p>I’ve enabled two-factor authentication on quite a few services I use and wanted to understand how the one-time password was being generated. I was surprised to learn quite how simple the algorithms are and thought I’d share what I understand. This post describes how to generate HOTPs in Ruby before moving on to demonstrate how the same code can be used to generate TOTPs.</p>
          <h2 id="generating-an-hotp-in-ruby">Generating an HOTP in Ruby</h2>
          <p>The step numbers (1 to 3) below correspond to the steps in section 5.3 (“Generating an HOTP Value”) of <a href="https://www.ietf.org/rfc/rfc4226.txt">HOTP RFC 4226</a>.</p>
          <h3 id="generate-an-hmac-sha-1-value">1. Generate an HMAC-SHA-1 value</h3>
          <p>I’m using the key and a counter from the Test Values in Appendix D of HOTP RFC 4226 so that we can verify the output. In the real world you’d be given the key (often encoded in a QR code) by the site that you’re enabling 2FA for.</p>
          <p>The resulting HMAC is a 20 byte (160 bit) string.</p>
          <pre><code class="language-ruby">require 'openssl'

key = '12345678901234567890'
counter = 5
counter_as_byte_string = [counter].pack('Q&gt;')

digest = OpenSSL::Digest.new('sha1')
hmac = OpenSSL::HMAC.digest(digest, key, counter_as_byte_string)

puts hmac.unpack('H*')
#=&gt; 'a37e783d7b7233c083d4f62926c7a25f238d0316'
# Or as an array
# [0xa3, 0x7e, 0x78, 0x3d, 0x7b, 0x72, 0x33, 0xc0, 0x83, 0xd4,
#  0xf6, 0x29, 0x26, 0xc7, 0xa2, 0x5f, 0x23, 0x8d, 0x03, 0x16]
</code></pre>
          <h3 id="generate-a-4-byte-string">2. Generate a 4-byte string</h3>
          <h4 id="a-generate-the-offset">2a. Generate the offset</h4>
          <p>The offset is the number represented by the last 4 bits of the last byte.</p>
          <pre><code class="language-ruby">offset = hmac.bytes.last & 0x0f
# Equivalent to: 0x16 & 0x0f
# Equals: 0x06
# Or as a decimal: 6
</code></pre>
          <h4 id="b-take-4-bytes-starting-at-the-offset">2b. Take 4 bytes starting at the offset</h4>
          <pre><code class="language-ruby">bytes = hmac.bytes[offset..offset + 3]
# Equivalent to: hmac.bytes[6..9]
# Equals: [0x33, 0xc0, 0x83, 0xd4]
# Or as decimals: [51, 192, 131, 212]
</code></pre>
          <h4 id="c-mask-the-most-significant-bit-of-the-first-byte">2c. Mask the most significant bit of the first byte</h4>
          <p>To avoid any confusion around signed vs unsigned integers.</p>
          <pre><code class="language-ruby">bytes[0] = bytes[0] & 0x7f
# Equivalent to: 0x33 & 0x7f
# Equals: 0x33 # No-op in this instance
</code></pre>
          <h3 id="compute-an-hotp-value">3. Compute an HOTP value</h3>
          <h4 id="a-convert-the-4-bytes-into-a-32bit-integer">3a. Convert the 4 bytes into a 32bit integer</h4>
          <p>There are two implementations below. The first uses bit-shifting and the second (suggested by <a href="/james-mead">James</a>) uses <code>Array#pack</code> and <code>String#unpack</code>. While the second implementation is more concise, I’ve retained both as I think the first makes it easier to see what’s going on.</p>
          <pre><code class="language-ruby"># 1. Bit-shifting
bytes_as_integer = (bytes[0] &lt;&lt; 24) + (bytes[1] &lt;&lt; 16) + (bytes[2] &lt;&lt; 8) + bytes[3]
# Equivalent to: (0x33 &lt;&lt; 24) + (0xc0 &lt;&lt; 16) + (0x83 &lt;&lt; 8) + 0xd4
# or in decimal: (51 * (2**24)) + (192 * (2**16)) + (131 * (2**8)) + 212
# Equals: 855638016 + 12582912 + 33536 + 212
# Equals: 868254676

# 2. Using `Array#pack` and `String#unpack`
bytes_as_integer = bytes.pack('c*').unpack('N')[0]
# Equals: 868254676
</code></pre>
          <h4 id="b-generate-otp">3b. Generate OTP</h4>
          <p>The OTP is the last n digits (6 by default) of the number we’ve generated.</p>
          <pre><code class="language-ruby">digits = 6
puts bytes_as_integer.modulo(10 ** digits)
# Equivalent to: 868254676.modulo(1_000_000)
#=&gt; 254676
</code></pre>
          <h3 id="the-code-in-full">The code in full</h3>
          <pre><code class="language-ruby">require 'openssl'

def generate_otp(key, counter, digits = 6)
  counter_as_byte_string = [counter].pack('Q&gt;')
  digest = OpenSSL::Digest.new('sha1')
  hmac = OpenSSL::HMAC.digest(digest, key, counter_as_byte_string)
  offset = hmac.bytes.last & 0x0f
  bytes = hmac.bytes[offset..offset + 3]
  bytes[0] = bytes[0] & 0x7f
  bytes_as_integer = (bytes[0] &lt;&lt; 24) + (bytes[1] &lt;&lt; 16) + (bytes[2] &lt;&lt; 8) + bytes[3]
  bytes_as_integer.modulo(10 ** digits)
end

otp = generate_otp('12345678901234567890', 5)
puts "OTP: %s" % otp
</code></pre>
          <h2 id="generating-totps">Generating TOTPs</h2>
          <p>The TOTP algorithm builds on HOTPs by specifying how the value of the counter should be calculated. This avoids the need to synchronise the counter between the server (e.g. GitHub) and the client (e.g. Authy) as both parties can calculate it in the same way.</p>
          <p>The counter specified in <a href="https://tools.ietf.org/rfc/rfc6238.txt">the TOTP RFC</a> is the number of 30 second intervals in the current <a href="https://en.wikipedia.org/wiki/Unix_time">unix time</a>.</p>
          <p>We can demonstrate the relationship between TOTPs and HOTPs using <code>oathtool</code> from the <a href="http://www.nongnu.org/oath-toolkit/">OATH Toolkit</a>. We start by generating a TOTP based on the current time and then show that we can generate the same HOTP by using the counter we’re given in the verbose output.</p>
          <pre><code class="language-bash"># Generate TOTP for current time
$ oathtool --totp --verbose 3132333435363738393031323334353637383930
Hex secret: 3132333435363738393031323334353637383930
Base32 secret: GEZDGNBVGY3TQOJQGEZDGNBVGY3TQOJQ
Digits: 6
Window size: 0
Step size (seconds): 30
Start time: 1970-01-01 00:00:00 UTC (0)
Current time: 2016-12-21 10:52:10 UTC (1482317530)
Counter: 0x2F1F218 (49410584)

744955

# Generate HOTP using counter above
$ oathtool --hotp --counter 49410584 3132333435363738393031323334353637383930
744955
</code></pre>
          <p>Note that the key we pass to <code>oathtool</code> above is the hex encoded representation of the example key we’re using in our Ruby script.</p>
          <pre><code class="language-ruby">'12345678901234567890'.unpack('H*')
=&gt; ["3132333435363738393031323334353637383930"]
</code></pre>
          <p>Now that we know that the only difference is in the value of the counter we can update our Ruby script to generate TOTPs.</p>
          <pre><code class="language-ruby">counter = Time.now.to_i / 30 # 30 second intervals in current unix time

otp = generate_otp('12345678901234567890', counter)
puts "OTP: %s" % otp
</code></pre>
          <p>Assuming we’ve saved the Ruby script as totp.rb, we can use <code>oathtool</code> to verify the generated OTP.</p>
          <pre><code class="language-bash">$ ruby totp.rb
662110

$ oathtool --totp 3132333435363738393031323334353637383930
662110
</code></pre>
          <h2 id="conclusion">Conclusion</h2>
          <p>I hope this post helps illustrate how relatively simple these two algorithms are. While the code certainly seems to work, there are no tests and I have no idea about its performance. If you’re looking to use something like this in production then you might want to check out <a href="https://github.com/mdp/rotp">The Ruby One Time Password Library</a> (I’ve not tried this but it seems to have some tests) or the OATH Toolkit mentioned earlier.</p>
          <p>After reading a draft of this post, <a href="http://po-ru.com/">Paul</a> pointed me to this <a href="https://garbagecollected.org/2014/09/14/how-google-authenticator-works/">How Google Authenticator Works blog post from a couple of years ago</a>. The author also wanted to understand how these one-time passwords are generated and has described the algorithm in their post. It might be worth reading if this post leaves you with unanswered questions.</p>
        </div>
        <div class="comments" id="comments">
          Disqus commenting is only enabled in production.
        </div>
      </div>
      <div id="article_links">
        <h3>Recent</h3>
        <div id="recent_articles">
          <ol class="blog_list" reversed="">
            <li value="6">
              <a href="/week-446-links">Week 446 - Interesting links</a>
            </li>
            <li value="5">
              <a href="/week-444">Week 444</a>
            </li>
            <li value="4">
              <a href="/week-444-links">Week 444 - Interesting links</a>
            </li>
            <li value="3">
              <a href="/week-443">Week 443</a>
            </li>
            <li value="2">
              <a href="/week-441">Week 441</a>
            </li>
            <li value="1">
              <a href="/week-442">Week 442</a>
            </li>
          </ol>
        </div>
      </div>
    </div>
  </div>
  <script src="/assets/application-a06a15e76d88968aa98de5792d639d527018444227ecda8004f3fb4a3e0d1d6f.js">
  </script> 
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45002715-1', 'gofreerange.com');
  ga('send', 'pageview');

  </script>
</body>
</html>
